Software plays a central role in all modern space systems. Such systems can be unmanned satellites, probes to other planets and landers descending on them, manned space stations and the transport vehicles to reach them. Each of them relies on multiple computing units utilizing software to perform their functionality.

This software is implemented using programming languages. These languages are designed in such a way that they can be understood by humans as well as machines, allowing former to create unambiguous programs that can be performed by the latter. Historically, programming languages started very close to the function of the machine, but over time, the level of abstraction grew. The languages became easier to use for humans as more sophisticated translators became available, that were able to translate the human usable language to the code executable by the machine. Nowadays, a broad spectrum of languages is available, suited for different tasks and situations.

For space systems, however, not the full spectrum of languages is usable. As most large scale space programs are risk-averse, choice of the programming language, and other formal methods during software development within the programs, are heavily influenced by heritage and other organizational criteria. The whole embedded systems landscape, which space computing systems are a part of, does not have a diverse set of available languages. Microcontroller manufacturers typically provide a C or C++ compiler, be it proprietary or Open Source, and \\glspl{HAL} for C/C++. Storage and memory constraints further limit the set of suitable languages. As a result, C and C++ are dominating in this field with little alternatives. In addition to that, the space system design philosophy is dominated by highly reliable components and conservative designs to achieve long lifetimes in the harsh space environment. In this environment, it is not easy to experiment with new languages and tools, which leads to slow adoption of new techniques and ideas.

At the same time, software is one of the critical aspects of success or failure for space missions. Multi-million dollar losses like Mars Climate Orbiter [@polar], Ariane 5 flight 501 [@lions] and Mars Polar Lander [@euler] can be traced back directly to software flaws. As the scope of space systems, similar to terrestrial ones, broadens, the complexity of the on-board software historically increased over the years. An exponential growth rate of a factor of 10 approximately every 10 years was observed for software code in unmanned NASA spacecraft over the last 40 years [@Dvorak].

When a systems complexity rises and the introduction of new tools to manage it is slow, the result is a higher risk of errors.

To overcome the limitations of traditional space programs, CubeSats attempted to choose a different philosophy. They utilize suitable state-of-the-art, commercial-off-the-shelf products to build small, standardized satellites, which can be built and launched at lower cost. Novel computer architectures as well as new tools and programming languages can be researched with less resources and risk than in traditional space programs.

A way to manage the rising software complexity is to use higher-level programming languages. Their higher abstraction level makes them easier to use and more expressive. This leads to smaller programs containing less errors. Python is such a higher-level language that can address the complexity problems of growing software systems by an increased usability. The design focus of Python is readability, making it a language that is easy to learn and use. However, the standard implementation of this language, CPython, is very resource heavy. It uses a lot of storage and memory and is also slower than comparable programs written in C. It also can not run on microcontrollers due to its memory and storage requirements.
To address those issues, MicroPython has been developed. It implements the Python 3 programming language for microcontrollers and memory constrained systems, thus allowing the use of the Python language on space systems.

To evaluate the potential of MicroPython to ease the complexity issues, CubeSats provide a fitting testbed. The MOVE-II satellite project [@Langer] of the Technical University of Munich attempts to built such a CubeSat and is used as the framework for this evaluation. Within the project, there are already several novel computing concepts being investigated. Among others, this includes a fault-tolerant, radiation-robust filesystem [@filesystem], autonomous Chip Level debugging [@debugging], dependable data storage on miniaturized satellites [@datastorage] and a novel communication protocol for miniaturized satellites [@appel].

![A rendering of the MOVE-II satellite.\\label{moveii}](resources/figs/MOVE-II_Rendering.png){ width=90% }

MOVE-II is a 1U CubeSat, shown in Figure \\ref{moveii}, which means its outer dimensions are roughly defined by a $10~cm$ cube. It has four side-panels, equipped with solar cells for generating power, which are deployed after the release of the satellite from the launcher by a shape memory alloy mechanism. Experimental solar cells mounted on the top-panel are the scientific payload. These cells are tested for degradation under space conditions. For communication, the satellite uses an UHF/VHF system as well as an S-band system, with the corresponding antennas. Magnetorquers acting against the earths magnetic field are used to de-tumble and orient the CubeSat in space. Figure \\ref{moveiip} shows the satellite during the first integration test.

![The MOVE-II satellite during integration testing.\\label{moveiip}](resources/figs/int.jpg){ width=45% }

The aim of this work is to evaluate the suitability of MicroPython to program software used in space. This is done by using classic language evaluation as well as practical example implementations and comparisons between languages. The MOVE-II CubeSat project acts as a framework for this evaluation, providing real-world examples and targets. It is, however, not planned to use MicroPython on the CubeSat being launched, as the project timeline of MOVE-II does not allow that.

The next chapter details the motivation for the research. Chapter 3 deals with the background of Python, programming language evaluation, a project-based evaluation approach and metrics usable to compare code complexity. In Chapter 4, the methods used for evaluation are introduced. Results and first conclusions are later given in Chapter 5. Finally, in Chapter 6, I conclude with the implications of this work for space software development and give an outlook on future steps to incorporate MicroPython in the development work-flow.

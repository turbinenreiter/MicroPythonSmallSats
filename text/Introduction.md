For decades, satellite design philosophy was dominated by highly reliable components and conservative designs to achieve long lifetimes in the harsh space environment. Since the beginning of the space age, autonomy and control of the spacecraft made software one of the critical aspects of success or failure. Multi-million dollar losses like Mars Climate Orbiter [@polar], Ariane 5 flight 501 [@lions] and Mars Polar Lander [@euler] can be traced back directly to software flaws. As the scope of space systems, similar to terrestrial ones, broadens, the complexity of the on-board software historically increased over the years. An exponential growth rate of a factor of 10 approximately every 10 years was observed for software code in unmanned NASA spacecraft over the last 40 years [@Dvorak].

As most large scale space programs are risk-averse, choice of the programming language and other formal methods during software development within the programs are heavily influenced by heritage and other organizational criteria. Furthermore, the whole embedded systems landscape, of which space computing systems are a part of, does not have a diverse set of available languages. For microcontrollers, which are meant to be used without an operating system, C and C++ are the only commonly available languages. Microcontroller manufacturers provide a C or C++ compiler, be it proprietary or Open Source, and hardware abstraction libraries for C/C++. The Arduino project, which has made microcontroller programming accessible to a broader audience, also uses a language that is essentially C++. Alternative languages are usually not supplied by the microcontroller companies, but by Open Source projects, and target only certain microcontrollers or microcontroller families.

One of these alternative language projects is MicroPython, which implements the Python 3 programming language for microcontrollers. Python is a language with a design focus on readability, making it easy to learn and use. Thus, it can address the complexity problems of growing software systems by an increased usability. It also adds an additional tool to the developer's toolbox, allowing them to chose tools that better fit the problems to solve.

To overcome the limitations of traditional space programs, CubeSats attempted to choose a different philosophy. They utilize suitable state-of the art, commercial-off-the shelf products to build small, standardized satellites, which can be built and launched at lower cost. Novel computer architectures as well as programming and scripting languages can be researched with less resources and risk than in traditional space programs.

The MOVE-II satellite project [@Langer] of the Technical University of Munich attempts to built such a CubeSat. Within the project, several novel computing concepts are investigated. Among others, this includes a fault-tolerant, radiation-robust filesystem [@filesystem], autonomous Chip Level debugging [@debugging], dependable data storage on miniaturized satellites [@datastorage] and a novel communication protocol for miniaturized satellites [@appel].

This thesis will add an evaluation of using MicroPython as application layer programming language on CubeSats to the MOVE-II project.

![MOVE-II Project Logo\\label{logo}](resources/figs/MOVE-Logo.pdf){ width=25% }

MOVE-II is a 1U CubeSat, shown in Figure \\ref{moveii}, which means it outer dimensions are roughly $10~cm x 10~cm x 10~cm$. It has four side-panels, equipped with solar cells for generating power, which are deployed after the release of the satellite from the launcher by a shape memory alloy mechanism. The scientific payload are experimental solar cells mounted on the top-panel. These cells are tested for degradation under space conditions. For communication, the satellite uses an UHF/VHF system as well as a S-band system, with the corresponding antennas. Magnetorquers acting against the earths magnetic field are used to de-tumble and orient the CubeSat in space.

![MOVE-II Satellite Rendering\\label{moveii}](resources/figs/rendering_move_ii_web.png){ width=25% }

First, the motivation for the research is given in chapter 2. Chapter 3 deals with the background of Python, programming language evaluation, a project-based evaluation approach and metrics usable to compare code complexity. In Chapter 4, the methods used for evaluation are introduced. Results and first conclusions are later given in Chapter 5. Finally, in Chapter 6, I conclude with the implications of this work for space software development and give an outlook on future steps to incorporate MicroPython in the development work-flow.

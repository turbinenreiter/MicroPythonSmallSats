\cleardoublepage
\section*{Abstract}

Since the beginning of the space age, software has always been a critical aspect for any space mission launched. Over the decades, more complexity, autonomy and functionality was added to both unmanned and manned missions, yielding in an exponential growth of software size. Despite a lot of effort being put into ensuring software reliability, some missions failed. Still, as the space industry is a risk-averse business, testing of novel approaches for writing space software cannot be done on a large scale.

CubeSats provide a way to overcome this limitation. They are small, standardized satellites that provide cheap access to space and open up the possibility for experimentation with new tools.

To address the rising software complexity, higher level programming languages like Python can be used. Python is a dynamic language, that is easy to use and learn and can help managing complexity by having better usability. The standard implementation, however, does not work on the hardware typically used in space. For this purpose, MicroPython can be used: it is an implementation of the Python 3 programming language for microcontrollers and memory constrained systems.

This thesis investigates the potential of MicroPython for use on CubeSats to address rising complexity. The language is analyzed by using practical examples from the MOVE-II CubeSat project. While MOVE-II is the source of the examples, MicroPython will not yet be used on the flight model, because this evaluation is happening to late in the satellites design process.

To evaluate the space readiness of MicroPython a number of methods were used. First, a programming language evaluation using a canonical set of criteria showed the language to be well designed and having good readability, which is important for software maintenance. A project-based evaluation was done to investigate the suitability of the language for an example software taken from the MOVE-II project. This showed that while Python's usability makes it attractive, the execution speed and storage requirements were problematic. MicroPython addresses the storage problem, but not the speed problem. After that, example implementations of software needed by MOVE-II were done to investigate whether or not programs written with MicroPython can fulfill all requirements in practice. The resulting programs complexity was compared between using MicroPython and C. It was possible to implement all needed functionality and the complexity was generally lower when using MicroPython. However, the benefits were stronger for programs that provide high level control of the system, and weaker for programs that interact directly with the hardware, like device drivers. To address the slower speed of the MicroPython programs, the creation of modules written in C but used from Python was investigated. MicroPython allows doing so in a straightforward fashion and the resulting speed was in the same order of magnitude than the C version.

The results of this evaluation are promising, but further work is needed. The evaluation method needs refinement to be more generally applicable and better specified. To prove MicroPython's space readiness, ultimately it has to be shown working in space. This could be done on the MOVE-II CubeSat after it's primary mission is fulfilled, by deploying MicroPython and a test program as a software update. While MicroPython can be used for all types of programs, it is best suited for writing the top level control software, implementing the systems operations. Lower level software, like drivers or performance critical algorithms can be prototyped in MicroPython, but are better written as C modules usable from Python.
